import re
import os
import time
from agents.baseline import BaselineAgent
from agents.component_path import ComponentPathAgent
from file_watcher import FileWatcher
import shutil
import json
from pydantic import BaseModel
from typing import Optional
import subprocess
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

CodeAgent = BaselineAgent()
PathAgent = ComponentPathAgent()


class FileContext(BaseModel):
    file_path: str
    file_content: str
    root_directory: str
    mount_dir: str
    working_dir: str
    example_content: Optional[str] = None


class BrewContext(FileContext):
    brew_path: str
    brew_content: str
    coffee_import_statement: str
    coffee_tag: dict


def process_file(file_path, mount_dir=None, root_directory=None, example=None):
    """
    Detects and processes <Coffee> and <Component coffee="..."> tags.
    """
    with open(file_path, "r") as file:
        file_content = file.read()

    example_content = None
    if example:
        example_path = os.path.join(root_directory, "./" + example)
        try:
            with open(example_path, "r") as example_file:
                example_content = example_file.read()
        except FileNotFoundError:
            print(f"Could not find example file at {example_path}")
            return

    ctx = FileContext(
        file_path=file_path,
        file_content=file_content,
        root_directory=root_directory,
        mount_dir=mount_dir,
        working_dir=os.path.join(os.path.dirname(file_path), mount_dir),
        example_content=example_content,
    )

    # Extract and process <Coffee> tag
    coffee_tag = extract_tag(file_content, tag="Coffee")
    if coffee_tag:
        print(f"<Coffee> tag found in {file_path}")
        new_files = process_coffee_tag(coffee_tag=coffee_tag, ctx=ctx)
        # Run Prettier on all processed files
        for new_file in new_files:
            run_prettier_on_file(new_file)

    # Extract and process <Component coffee="..."> caffeinated components
    caffeinated_component = extract_tag(
        file_content, attribute="coffee=[\"'][^\"']+[\"']"
    )
    if caffeinated_component:
        print(f"Caffeinated component found in {file_path}")
        new_files = proccess_caffeinated_component(
            caffeinated_component=caffeinated_component, ctx=ctx
        )
        # Run Prettier on all processed files
        for new_file in new_files:
            run_prettier_on_file(new_file)


def process_coffee_tag(coffee_tag=None, ctx: FileContext = None):
    """
    Brews or Pours <Coffee> components.
    """
    working_dir = os.path.join(os.path.dirname(ctx.file_path), ctx.mount_dir)
    coffee_import_statement = f"import Coffee from '{ctx.mount_dir}/Coffee'\n"
    extension = ctx.file_path.split(".")[-1]
    brew_path = os.path.join(working_dir, "Brew." + extension)
    brew_content = ""

    if os.path.exists(brew_path):
        with open(brew_path, "r") as brew_file:
            brew_content = brew_file.read()
    brew_ctx = BrewContext(
        **ctx.dict(),
        brew_path=brew_path,
        brew_content=brew_content,
        coffee_import_statement=coffee_import_statement,
        coffee_tag=coffee_tag,
    )
    pour = coffee_tag["props"].get("pour", None)
    ignored_files = [".d.ts"] if extension not in ["ts", "tsx"] else []
    if pour:
        print(f"Pouring component to {pour}...")
        mount_coffee_files(
            "./mount",
            working_dir,
            False,
            cleanup=[brew_path],
            without=ignored_files
        )
        pour_component(pour_path=pour, ctx=brew_ctx)
        # Run Prettier on the poured component
        component_file_path = os.path.join(working_dir, pour)
        print(f"Generated component file path: {component_file_path}")
        run_prettier_on_file(component_file_path)
        
        # Process and format any additional files generated by the pour operation
        process_generated_files(working_dir, pour)
    else:
        print("Brewing new component...")
        mount_coffee_files(
            "./mount",
            working_dir,
            True,
            without=ignored_files
        )
        brew_component(ctx=brew_ctx)
        # Run Prettier on the brewed component
        print(f"Brewed component file path: {brew_path}")
        run_prettier_on_file(brew_path)

    return


def process_generated_files(working_dir, pour_file):
    """
    Process and format any additional files generated by the pour operation.
    """
    pour_name = os.path.splitext(pour_file)[0]
    for root, dirs, files in os.walk(working_dir):
        for file in files:
            if file.startswith(pour_name) and file.endswith(('.js', '.jsx', '.ts', '.tsx')):
                file_path = os.path.join(root, file)
                print(f"Processing generated file: {file_path}")
                run_prettier_on_file(file_path)


def brew_component(ctx: BrewContext = None):
    file_content, modfied = set_import(
        ctx.file_content, ctx.coffee_import_statement, True
    )
    if modfied:
        with open(ctx.file_path, "w") as file:
            file.write(file_content)

    prompt = ctx.coffee_tag["children"]

    for update in CodeAgent.modify_file(
        source_file=ctx.brew_path,
        user_query=prompt,
        file_content=ctx.brew_content,
        parent_file_content=file_content,
        example_content=ctx.example_content,
    ):
        print(update)


def pour_component(pour_path=None, attributes_to_remove=["brew", "pour"], ctx: BrewContext = None):
    """
    Replaces the <Coffee> tag with <BrewedComponent>.
    1. Replace <Coffee ...> </Coffee> tag with <ComponentName ...props />
    2. Append import ComponentName from './coffee/brew/ComponentName' after the last import statement.
    """

    # Replace tag
    component_name = pour_path.split(".")[0]
    coffee_start, coffee_end = ctx.coffee_tag["match"].span()
    attributes = ctx.coffee_tag["attributes"]
    for attr in attributes_to_remove:
        attributes = re.sub(rf'\b{attr}="[^"]+"\s*|\b{attr}\b\s*', "", attributes)
    file_content = ctx.file_content
    file_content = (
        file_content[:coffee_start]
        + f"<{component_name} {attributes.strip()} />"
        + file_content[coffee_end:]
    )

    # Update import statements
    import_statement = (
        f"import {component_name} from '{ctx.mount_dir}/{component_name}'\n"
    )
    file_content, _ = set_import(file_content, import_statement, True)
    file_content, _ = set_import(file_content, ctx.coffee_import_statement, False)

    # Create component file
    component_file_path = os.path.join(
        os.path.dirname(ctx.file_path), ctx.mount_dir, pour_path
    )
    with open(component_file_path, "w") as component_file:
        component_file.write(ctx.brew_content)

    print(f"Component file created at {component_file_path}")
    run_prettier_on_file(component_file_path)

    # Update parent file
    with open(ctx.file_path, "w") as file:
        file.write(file_content)

    # Update component file to reflect the new name
    for update in CodeAgent.modify_file(
        source_file=component_file_path,
        user_query=f"Update component file to reflect the new component name: {component_name}",
        file_content=ctx.brew_content,
        parent_file_content=file_content,
        example_content=ctx.example_content,
    ):
        print(update)

    print("Replacement complete.")


def proccess_caffeinated_component(caffeinated_component=None, ctx: FileContext = None):
    component_name = caffeinated_component["tag"]
    import_pattern = rf"({component_name})(.*?)from\s[\'\"](.*?)[\'\"]"
    match = re.search(import_pattern, ctx.file_content, re.DOTALL)

    if not match:
        print(f"Could not find import statement for {component_name}")
        return

    component_file_path = None
    for update in PathAgent.run(
        component=component_name,
        parent_file_path=ctx.file_path,
        import_statement=match.group(0),
        directory=root_directory,
    ):
        print(update)
        if isinstance(update, dict) and update.get("file_path"):
            component_file_path = update["file_path"]

    if not component_file_path:
        print(f"Could not find component file for {component_name}")
        return

    with open(component_file_path, "r") as component_file:
        component_file_content = component_file.read()
        if not component_file_content:
            # TODO: handle back-and-forth with agent if file content is not found
            print(
                f"Could not read component file for {component_name} at {component_file_path}"
            )
            return

    for update in CodeAgent.modify_file(
        user_query=caffeinated_component["props"]["coffee"],
        source_file=component_file_path,
        file_content=component_file_content,
        parent_file_content=ctx.file_content,
        example_content=ctx.example_content,
    ):
        print(update)

    # Run Prettier on the modified component file
    run_prettier_on_file(component_file_path)


def extract_tag(file_content, tag="\\w+", attribute=""):
    """
    Extracts a tag from the file content based on the tag name and additional attributes.
    """
    pattern = rf"<({tag})\s?([^>/]*?{attribute}[^>/]*)(?:>(.*?)</{tag}>|/>)"
    match = re.search(pattern, file_content, re.DOTALL)

    if match:
        tag_name, attributes, content = match.groups()
        props = {
            m[0]: m[1] or True
            for m in re.findall(r'(\w+)(?:=["\']([^"\']+)["\']|\b)', attributes)
        }
        return {
            "match": match,
            "tag": tag_name,
            "props": props,
            "children": content.strip() if content else "",
            "attributes": attributes,
        }

    return None


def set_import(file_content, import_statement, upsert=True):
    """
    Adds or removes the import statements from file_content.
    """
    remove = not upsert
    import_index = file_content.find(import_statement)
    modified = False

    if remove and import_index != -1:
        file_content = (
            file_content[:import_index]
            + file_content[import_index + len(import_statement) :]
        )
        modified = True
    if upsert and import_index == -1:
        insert_index = file_content.find(
            "\n", file_content.find("from", file_content.rfind("import "))
        )
        file_content = (
            file_content[: insert_index + 1]
            + import_statement
            + file_content[insert_index + 1 :]
        )
        modified = True

    return file_content, modified


def mount_coffee_files(source, target, mount=True, cleanup=[], without=[]):
    """
    Mount or unmount the source directory to the target directory.
    """
    if mount and not os.path.exists(target):
        os.makedirs(target)
    for item in os.listdir(source):
        s = os.path.join(source, item)
        d = os.path.join(target, item)

        if any(s.endswith(ext) for ext in without):
            continue

        if os.path.isdir(s):
            os.symlink(s, d) if mount else os.remove(d)
        else:
            shutil.copy2(s, d) if mount else os.remove(d)

    if not mount and len(cleanup):
        for path in cleanup:
            os.remove(path)


DEFAULT_CONFIG = {
  "mount": "./components",
  "patterns": ["**/*.js", "**/*.jsx", "**/*.ts", "**/*.tsx"],
  "example": None,
}


def parse_config(path):
    """
    Reads and parses config file
    """
    try:
        with open(path, "r") as file:
            return dict(DEFAULT_CONFIG, **json.load(file))
    except FileNotFoundError:
        return DEFAULT_CONFIG


class CombinedWatcher(FileSystemEventHandler):
    def __init__(self, root_directory, watch_patterns, ignore_patterns, mount_dir):
        self.root_directory = root_directory
        self.watch_patterns = watch_patterns
        self.ignore_patterns = ignore_patterns
        self.mount_dir = mount_dir
        self.observer = Observer()
        self.components_dir = os.path.join(root_directory, '_roastery', 'sample_app_nextjs', 'app', 'components')
        print(f"Watching components directory: {self.components_dir}")
        print(f"Watch patterns: {self.watch_patterns}")

    def start(self):
        self.observer.schedule(self, self.root_directory, recursive=True)
        self.observer.start()
        print(f"Watcher started for {self.root_directory}")

    def stop(self):
        self.observer.stop()
        self.observer.join()
        print("Watcher stopped")

    def on_created(self, event):
        if not event.is_directory:
            self._handle_file_event(event.src_path, "created")

    def on_modified(self, event):
        if not event.is_directory:
            self._handle_file_event(event.src_path, "modified")

    def _handle_file_event(self, file_path, event_type):
        print(f"File {event_type}: {file_path}")
        if self._should_process_file(file_path):
            print(f"Processing {event_type} file: {file_path}")
            self._run_prettier_on_file(file_path)

    def _should_process_file(self, file_path):
        print(f"Checking file: {file_path}")
        
        if '.next' in file_path:
            print("File is in .next directory, skipping")
            return False

        in_components = 'components' in file_path.split(os.path.sep)
        print(f"In components folder: {in_components}")

        file_extension = os.path.splitext(file_path)[1]
        matches_pattern = any(pattern.endswith(file_extension) for pattern in self.watch_patterns)
        print(f"File extension: {file_extension}")
        print(f"Matches watch pattern: {matches_pattern}")

        is_ignored = any(ignore_pattern in file_path for ignore_pattern in self.ignore_patterns)
        print(f"Is ignored: {is_ignored}")

        should_process = in_components and matches_pattern and not is_ignored
        print(f"Should process file {file_path}? {should_process}")
        return should_process

    def _run_prettier_on_file(self, file_path):
        print(f"Running Prettier on file: {file_path}")
        try:
            result = subprocess.run(['npx', 'prettier', '--write', file_path], 
                                    check=True, 
                                    capture_output=True, 
                                    text=True,
                                    cwd=os.path.dirname(file_path))
            print(f"Prettier command executed for {file_path}")
            print(f"Prettier stdout: {result.stdout}")
            print(f"Prettier stderr: {result.stderr}")
        except subprocess.CalledProcessError as e:
            print(f"Error running Prettier on {file_path}: {e}")
            print(f"Error output: {e.stderr}")
        except Exception as e:
            print(f"Unexpected error running Prettier: {str(e)}")

    def check_components_directory(self):
        print("Checking components directory for new files...")
        for root, dirs, files in os.walk(self.components_dir):
            for file in files:
                full_path = os.path.join(root, file)
                if self._should_process_file(full_path):
                    print(f"Processing file: {full_path}")
                    self._run_prettier_on_file(full_path)
                else:
                    print(f"Skipping file: {full_path}")


def run_prettier_on_file(file_path):
    print(f"Running Prettier on file: {file_path}")
    try:
        result = subprocess.run(['npx', 'prettier', '--write', file_path], 
                                check=True, 
                                capture_output=True, 
                                text=True,
                                cwd=os.path.dirname(file_path))
        print(f"Prettier command executed for {file_path}")
        print(f"Prettier stdout: {result.stdout}")
        print(f"Prettier stderr: {result.stderr}")
        return "Prettier ran successfully"
    except subprocess.CalledProcessError as e:
        print(f"Error running Prettier: {e}")
        return f"Error: {str(e)}"
    except Exception as e:
        print(f"Unexpected error running Prettier: {str(e)}")
        return f"Unexpected error: {str(e)}"


def run_prettier_on_directory(directory):
    print(f"Starting to run Prettier on all files in {directory}")
    if not os.path.exists(directory):
        print(f"Directory {directory} does not exist. Skipping Prettier formatting.")
        return
    try:
        result = subprocess.run(['npx', 'prettier', '--write', '**/*.{js,jsx,ts,tsx}'], 
                                check=True, 
                                capture_output=True, 
                                text=True,
                                cwd=directory)
        print(f"Prettier output: {result.stdout}")
        print(f"Prettier errors: {result.stderr}")
    except subprocess.CalledProcessError as e:
        print(f"Error running Prettier on directory: {e}")
        print(f"Error output: {e.stderr}")
    except FileNotFoundError:
        print("Prettier not found. Skipping Prettier formatting.")
    except Exception as e:
        print(f"Unexpected error running Prettier: {str(e)}")


watcher = None

MOUNT_PATH = os.path.join(os.path.dirname(os.path.abspath(__file__)), "mount")

import os

if __name__ == "__main__":
    print("Script starting...", flush=True)
    print(f"OPENAI_API_KEY is {'set' if 'OPENAI_API_KEY' in os.environ else 'not set'}", flush=True)

    # Get the root directory of the entire coffee repo
    root_directory = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    config = parse_config(os.path.join(root_directory, "coffee.config.json"))

    # Ensure watch_patterns include .tsx files
    watch_patterns = config.get("patterns", ["**/*.js", "**/*.jsx", "**/*.ts", "**/*.tsx"])
    
    # Run Prettier on all files at startup
    run_prettier_on_directory(os.path.join(root_directory, '_roastery', 'sample_app_nextjs', 'app'))

    watcher = CombinedWatcher(
        root_directory,
        watch_patterns=watch_patterns,
        ignore_patterns=["Coffee.jsx", "Coffee.d.ts", "Brew.*"],
        mount_dir=config["mount"]
    )
    watcher.start()
    print("Watcher is now running. Waiting for file changes...")

    try:
        while True:
            time.sleep(0.5)  # Check every half second
            watcher.check_components_directory()
    except KeyboardInterrupt:
        print("Stopping...")
        watcher.stop()
        exit()